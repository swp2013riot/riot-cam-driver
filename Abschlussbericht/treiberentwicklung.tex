\section{Treiberentwicklung}
\subsection{Anaylse der Linux Treiber}
Für den verwendeten USB-Video-Grabber sind im Linux Kernel bereits zwei 
verschiedene Treiber vorhanden:
\begin{itemize}
 \item Das Modul easycap (nur in Kernel Version 2.6.x)
 \item Die Module stk1160 bzw. saa711x (ab Kernel Version 3.x.y)
\end{itemize}
Da diese Treiber auf ein im Linux Kern 
vorhandenes größeres Video Framework (V4L2) aufsetzten ist ein direktes Portieren der 
entsprechenden Kernel Module nach RIOT nicht ohne weiteres möglich gewesen.
Trotzdem waren die Linux Kernel Module extrem hilfreich bei der Entwicklung
des RIOT Treibers. Unter anderem konnte anhand dieser Module das zusammenspiel
der beiden Chips und die korrekte Ansteuerung selbiger ermittelt werden.
Insbesondere für den Gateway-Chip \stk{} spielten die Linux Treiber eine
besondere Rolle da für diesen Chip kein Datenblatt verfügbar ist. Die Linux 
Treiber waren somit die einzige, uns verfügbare Dokumentation, für diesen Chip. 

\subsubsection{Analyse auf Quellcode-Ebene}
Da es sich bei dem USB-Video-Grabber um einen Clone des weit verbreiteten
easycap-USB-Video-Grabber handelt hatten wir zunächst das easycap genannte Kernel
Modul welches in älteren Linux Versionen vorhanden ist betrachtet. Dieser Treiber
ist in modernern Versionen des Linux Kernel (3.x aufwärts) nicht mehr vorhanden.
Ein Grund hierfür ist die sehr schlechte Code-Qualität und die nahezu
nicht vorhandene Dokumentation dieses Moduls. Wegen der schlechten Lesbarkeits des
Codes war der Informationsgewinn durch das betrachten dieses Codes relativ gering.

In aktuelleren Linux Versionen ist sowohl ein Treiber für den \stk{} (Modulname: stk1160) 
wie auch für den \saa{} (Modulname: saa711x) Chip vorhanden. Diese Treiber sind im wesentlichen 
das Ergebnis eines refactoring des alten easycap Moduls. Der Code dieser Module ist wesentlich 
besser lesbar. Die Dokumentation ist aber auch in diesen Modulen eher mangelhaft. Insbesondere 
lassen sich im Code Kommentare finden die darauf schließen lassen, dass der Autor einige aus easycap übernommenen Teile selber nicht verstanden hat.

Trotz dieser Schwierigkeiten konnten wir anhand der neueren Kernel Module das Grundlegende Zusammenspiel der beiden beteiligten Chips nachvollziehen. Einige Unklarheiten sind jedoch erhalten geblieben. Insbesondere wird in den Modulen stk1160 und saa711x Gebrauch von geschachtelten Makros gemacht und nicht Dokumentierte magische Zahlen verwendet. 

\subsubsection{Anaylse auf funktionaler Ebene}
Unter Linux gibt es ein Kernel Modul (Modulename: usbmon) welches es erlaubt USB-Datentransfers zu beobachten bzw. 
mitzuschneiden. Als Frontend für dieses Modul kann, dass Netzwerkanalyseprogramm wireshark verwendet werden. 
Jedoch kann usbmon keine Datentransfers beobachten welche DMA (Direct Memory Access) nutzen. Da das stk1160 Modul für den 
asynchronen Datentransfer standardmäßig DMA verwendet waren wir gezwungen das Modul zu modifizieren.
Mit dem modifizierten stk1160, usbmon und wireshark war es uns anschließend möglich den Datentransfer zwischen PC
und USB-Video-Grabber im laufenden Betrieb zu beobachten.

\subsubsection{Analyseergebnisse}
Durch die Analyse der Linux Module erschloss sich uns das in \autoref{section:zusammenspiel} dargestellte Zusammenspiel der
beiden Chips. Des weiteren wurde klar, wie die Initialisierung, der Datentransfer, die Deinitialisierung des
USB-Video-Grabbers und die Kommunikation mit dem \saa{} funktioniert:

\paragraph{Kommunikation mit \saa{}:} Der \saa{} Chip kann von PC-Seite aus nur indirekt über den \stk{} Chip angesteuert werden.
Der \stk{} Chip kann angewiesen werden eine \iic{} Nachricht an den \saa{} Chip zu schicken indem der Inhalt der Nachricht in ein
spezielles Register geschrieben wird. Anschließend muss eine Reihe anderer Register mit speziellen Werten beschrieben werden um
die Nachricht abzuschicken. \textbf{!!!!!!!!LISTINGS?!!!!!!!!}

\paragraph{Initialisierung:}
\begin{enumerate}
 \item (\saa{} Chip über \iic{}) Der gewünschte Videostandard und andere Timing Parameter werden konfiguriert.
 \item (\saa{} Chip über \iic{}) Der \saa{} wird angewiesen Videodaten an den \stk{} weiterzuleiten.
 \item (\stk{} Chip) Der Chip wird angewiesen isochrone USB-Anfragen zu beantworten.
\end{enumerate}

\paragraph{Datentransfer:} Ist die Initialisierung abgeschlossen können vom PC isochrone USB Pakete an den USB-Video-Grabber
geschickt werden. Jedoch ist darauf zu achten, dass auf dem Host-Controller genügend Bandbreite für den Datentransfer reserviert wird
(vgl. \emph{Alternate Setting}). Im wesentlichen funktioniert der Datentransfer wie folgt:
\begin{enumerate}
 \item Leere Pakete (URBs) werden von dem PC an den \stk{} geschickt.
 \item Der \stk{} befüllt diese Pakete mit den Videodaten und sendet diese nach einer unbekannten Zeitspanne zurück an den Sender.
 \item Der Treiber hat einen asynchronen handler welcher beim eintreffen eines Antwortpaketes folgendermaßen agiert:
 \begin{enumerate}
  \item Die Integrität der Daten wird geprüft (anhand einer CRC16 Prüfsumme).
  \item Die Daten werden in einen Puffer geschrieben.
  \item Ein leeres Paket wird erzeugt und wieder an den \stk{} geschickt. 
 \end{enumerate}
\end{enumerate}
Die Fehlerbehandlung haben wir im Sinne der Übersichtlichkeit nicht dargestellt.

\paragraph{Deinitialisierung:}
\begin{enumerate}
 \item (\stk{} Chip) Weiterleiten von Daten, durch setzten von entsprechenden Registerwerten, stoppen.
 \item (\saa{} Chip über \iic{}) Streaming von Videodaten beenden.
 \item Puffer verwerfen, handler für die isochronen URBs beenden und reservierte Bandbreite auf dem Host-Controller wieder freigeben.
\end{enumerate}

\subsection{Aufbau und Funktionsweise des RIOT Treibers}
\subsubsection{Aufbau}
Das Quellcode von RIOT ist in zwei verschieden git repositories aufgeteilt. Im 
\riotrepo{} ist der Plattformunabhängige Teil des Treibers zu finden. In \boardsrepo{} hingegen ist der Plattformabhängige Teil enthalten. Darüber hinaus gibt es noch das \projectsrepo{} welches Test- und Demonstrationsprojekte enthält.

In \autoref{fig:srcoverviewriot} ist eine Liste der Dateien welche den Plattformunabhängigen Teil des Treibers bilden.\footnote{wobei RIOT/sys/auto\_init/auto\_init.c nicht direkt Teil des Treibers ist sondern nur modifiziert wurde} Ziel des Projektes war es einen Treiber für den native port von RIOT zu entwickeln. Daher ist der native port die einzige Plattform welche den Hardwareabhängigen Teil des Treibers enthält. In \autoref{fig:srcoverviewboards} sind die Treiber Dateien des native port abgebildet. Die in \autoref{fig:srcoverviewprojects} aufgelisteten Dateien stellen ein Demonstrationsprojekt dar welches die Benutzung des stk1160 Treibers veranschaulichen. 

Da der native Port auf einem Host-Betriebsystem (z.B. Linux) läuft wird mithilfe der Biblothek libusbx der USB Stack des Host-Systems an den native port durchgereicht. Dieser Umstand ist in der List der Dateien (\autoref{fig:srcoverviewboards}) nicht sichtbar. Zwecks Übersichtlichkeit sei daher auf den Abhängigkeitsgraph in \autoref{fig:dependsgraph} verwiesen.    

\newgeometry{top=0.5cm,bottom=1.5cm}
\begin{landscape}
\begin{figure}[htbp]
  \centering
  \begin{minipage}[b]{9cm}
  \begin{verbatim}
|-- RIOT
|   |-- core
|   |   |-- include
|   |       \-- usb.h
|   |-- drivers
|   |   |-- stk1160
|   |   |   |-- Makefile
|   |   |   |-- saa711x_regs.h
|   |   |   |-- stk1160.c
|   |   |   |-- stk1160.h
|   |   |   \-- stk1160-reg.h
|   |   \-- include
|   |       |-- stk1160_arch.h
|   |       \-- stk1160.h
|   \-- sys
|       |-- auto_init
|           \-- auto_init.c
    \end{verbatim}
 
    \caption{caption 1}
    \label{fig:srcoverviewriot}
  \end{minipage}
  \begin{minipage}[b]{9cm}
    \begin{verbatim}
|-- boards
|   |
|   |
|   |
|   |
|   |
|   |
|   |
|   |
|   |
|   |
|   |
|   |
|   \-- native
|       |-- drivers
|       |   \-- native-stk1160.c
|       \-- Makefile
    \end{verbatim}
    \caption{caption 2}
    \label{fig:srcoverviewboards}
  \end{minipage}
  \begin{minipage}[b]{9cm}
    \begin{verbatim}
|-- projects
|   |
|   |
|   |
|   |
|   |
|   |
|   |
|   |
|   |
|   |
|   |
|   |
|   |
|   \-- stk1160-test
|       |-- main.c
|       \-- Makefile
    \end{verbatim}
    \caption{caption 2}
    \label{fig:srcoverviewprojects}
  \end{minipage}
  \end{figure}
\end{landscape}
\restoregeometry

\begin{figure}[htbp]
 \centering
 \includegraphics{./DependsOnGraph-stk1160-c.png}
 % DependsOnGraph-stk1160-c.png: 406x400 pixel, 72dpi, 14.32x14.11 cm, bb=0 0 406 400
 \caption{Abhängigkeitsgraph des entwickelten Treibers für RIOT. Die Dateien descriptor.c, libusb.h, io.c, sync.c und core.c sind Teil von libusbx.}
 \label{fig:dependsgraph}
\end{figure}

\subsubsection{Funktionsweise}
Von einem Benutzer des Treibers wird zunächst die stk1160\_init Funktion aufgerufen. Diese wiederum führt, gemäß der Konventionen in RIOT, die dem Build Einstellungen entsprechenden Plattformabhängige Initialisierungsfunktion auf. In dem entwickelten Treiber kann es sich hierbei nur um stk1160\_arch\_init handeln.
Diese Funktion initialisiert libusbx, sucht nach dem USB-Video-Grabber und reserviert im Erfolgsfall das entsprechende USB-Inteface für den native port.

Sofern die Initialisierung des Treibers erfolgreich war kann anschließend stk1160\_start\__streaming durch den Benutzer aufgerufen werden. stk1160\_start\__streaming initialisiert sowohl den \stk1160 wie auch den \saa711x Chip und startet 
\subsection{Vorgehen bei der Implementierung}

\subsection{Probleme und Herausforderungen}

